<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eric的博客</title>
  
  <subtitle>My personal blog</subtitle>
  <link href="https://ericdxf.github.io/atom.xml" rel="self"/>
  
  <link href="https://ericdxf.github.io/"/>
  <updated>2022-05-16T09:51:04.841Z</updated>
  <id>https://ericdxf.github.io/</id>
  
  <author>
    <name>Eric Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arthas手册</title>
    <link href="https://ericdxf.github.io/2022/05/16/%E8%B5%84%E6%96%99/arthas%E6%89%8B%E5%86%8C/"/>
    <id>https://ericdxf.github.io/2022/05/16/%E8%B5%84%E6%96%99/arthas%E6%89%8B%E5%86%8C/</id>
    <published>2022-05-16T09:45:53.000Z</published>
    <updated>2022-05-16T09:51:04.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h3><ol><li><p>jdk路径下打开jvisualvm.exe软件</p><p><img src="https://gitee.com/dxf136/blog-image/raw/master/img/image-20210630143317123.png" alt="image-20210630143317123"></p></li><li><p>找到对应进程pid</p><p><img src="https://gitee.com/dxf136/blog-image/raw/master/img/image-20210630143445508.png" alt="image-20210630143445508"></p></li><li><p>进入arthas安装目录，cmd进入命令行，输入命令</p><pre><code>as.bat 16268</code></pre><p>其中16268为对应进程的pid</p><p><img src="https://gitee.com/dxf136/blog-image/raw/master/img/image-20210630143804200.png" alt="image-20210630143804200"></p></li><li><p>输入对应命令观察方法耗时情况</p><p><img src="https://gitee.com/dxf136/blog-image/raw/master/img/image-20210630143848120.png" alt="image-20210630143848120"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Windows系统&quot;&gt;&lt;a href=&quot;#Windows系统&quot; class=&quot;headerlink&quot; title=&quot;Windows系统&quot;&gt;&lt;/a&gt;Windows系统&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;jdk路径下打开jvisualvm.exe软件&lt;/p&gt;
&lt;p&gt;&lt;i</summary>
      
    
    
    
    <category term="工具" scheme="https://ericdxf.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="https://ericdxf.github.io/2022/04/24/%E8%B5%84%E6%96%99/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://ericdxf.github.io/2022/04/24/%E8%B5%84%E6%96%99/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2022-04-24T09:45:53.000Z</published>
    <updated>2022-05-16T08:44:58.629Z</updated>
    
    <content type="html"><![CDATA[<p>博客路径</p><p>E:Blog</p><p>Hexo博客搭建教程</p><p><a href="https://www.jianshu.com/p/745eacc56227">https://www.jianshu.com/p/745eacc56227</a></p><p>博客主题参考地址</p><p><a href="https://korilin.github.io/hexo-theme-particle-demo/full/public/">https://korilin.github.io/hexo-theme-particle-demo/full/public/</a></p><p>部署命令</p><pre><code class="bash">hexo g</code></pre><p>发布本地命令</p><pre><code class="bash">hexo s</code></pre><p>发布GitHub命令</p><pre><code class="bash">hexo d</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;博客路径&lt;/p&gt;
&lt;p&gt;E:Blog&lt;/p&gt;
&lt;p&gt;Hexo博客搭建教程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/745eacc56227&quot;&gt;https://www.jianshu.com/p/745eacc56227&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="博客相关" scheme="https://ericdxf.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="基础" scheme="https://ericdxf.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Nginx常用命令</title>
    <link href="https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2022-04-22T11:48:53.000Z</published>
    <updated>2022-04-22T11:40:29.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h1><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><pre><code>nginx -c /etc/nginx/conf/nginx.conf</code></pre><h3 id="关闭命令"><a href="#关闭命令" class="headerlink" title="关闭命令"></a>关闭命令</h3><pre><code>ps -ef|grep nginxkill -QUIT 2072</code></pre><h3 id="配置文件检测"><a href="#配置文件检测" class="headerlink" title="配置文件检测"></a>配置文件检测</h3><pre><code>nginx -t</code></pre><h3 id="重新加载配置文件"><a href="#重新加载配置文件" class="headerlink" title="重新加载配置文件"></a>重新加载配置文件</h3><pre><code>nginx -s reload</code></pre><h3 id="nginx配置location-x3D-x2F-uri-x2F-…-用法"><a href="#nginx配置location-x3D-x2F-uri-x2F-…-用法" class="headerlink" title="nginx配置location [&#x3D;||*|^~] &#x2F;uri&#x2F; { … }用法"></a>nginx配置location [&#x3D;|<del>|</del>*|^~] &#x2F;uri&#x2F; { … }用法</h3><ul><li><p>&#x3D; 严格匹配。如果这个查询匹配，那么将停止搜索并立即处理此请求。</p></li><li><p>~ 为区分大小写匹配(可用正则表达式)</p></li><li><p>!~为区分大小写不匹配</p></li><li><p>~* 为不区分大小写匹配(可用正则表达式)</p></li><li><p>!~*为不区分大小写不匹配</p></li><li><p>^~ 如果把这个前缀用于一个常规字符串,那么告诉nginx 如果路径匹配那么不测试正则表达式。</p><h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h6></li></ul><p>location &#x3D; &#x2F; {</p><p># 只匹配 &#x2F; 查询。</p><p>}</p><p>location &#x2F; {</p><p># 匹配任何查询，因为所有请求都以 &#x2F; 开头。但是正则表达式规则和长的块规则将被优先和查询匹配。</p><p>}</p><p>location ^~ &#x2F;p_w_picpaths&#x2F; {</p><p># 匹配任何以 &#x2F;p_w_picpaths&#x2F; 开头的任何查询并且停止搜索。任何正则表达式将不会被测试。</p><p>}</p><p>location ~*.(gif|jpg|jpeg)$ {</p><p># 匹配任何以 gif、jpg 或 jpeg 结尾的请求。</p><p>}</p><p>location ~*.(gif|jpg|swf)$ {</p><p>valid_referers none blocked start.igrow.cn sta.igrow.cn;</p><p>if ($invalid_referer) {</p><p>#防盗链</p><p>rewrite ^&#x2F; http:&#x2F;&#x2F;$host&#x2F;logo.png;</p><p>}</p><p>}</p><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><p>在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加&#x2F;，表示绝对根路径；如果没有&#x2F;，表示相对路径，把匹配的路径部分也给代理走。</p><p>假设下面四种情况分别用 <a href="http://192.168.1.1/proxy/test.html">http://192.168.1.1/proxy/test.html</a> 进行访问。</p><h5 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h5><p>location &#x2F;proxy&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1/">http://127.0.0.1/</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/test.html">http://127.0.0.1/test.html</a></p><h5 id="第二种（相对于第一种，最后少一个-x2F-）"><a href="#第二种（相对于第一种，最后少一个-x2F-）" class="headerlink" title="第二种（相对于第一种，最后少一个 &#x2F; ）"></a>第二种（相对于第一种，最后少一个 &#x2F; ）</h5><p>location &#x2F;proxy&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1/">http://127.0.0.1</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/proxy/test.html">http://127.0.0.1/proxy/test.html</a></p><h5 id="第三种："><a href="#第三种：" class="headerlink" title="第三种："></a>第三种：</h5><p>location &#x2F;proxy&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1/aaa/">http://127.0.0.1/aaa/</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/aaa/test.html">http://127.0.0.1/aaa/test.html</a></p><h5 id="第四种（相对于第三种，最后少一个-x2F-）"><a href="#第四种（相对于第三种，最后少一个-x2F-）" class="headerlink" title="第四种（相对于第三种，最后少一个 &#x2F; ）"></a>第四种（相对于第三种，最后少一个 &#x2F; ）</h5><p>location &#x2F;proxy&#x2F; {<br>    proxy_pass <a href="http://127.0.0.1/aaa">http://127.0.0.1/aaa</a>;<br>}<br>代理到URL：<a href="http://127.0.0.1/aaatest.html">http://127.0.0.1/aaatest.html</a></p><h3 id="rewrite-最后一项flag参数："><a href="#rewrite-最后一项flag参数：" class="headerlink" title="rewrite 最后一项flag参数："></a>rewrite 最后一项flag参数：</h3><ul><li>last</li></ul><ol><li>结束当前的请求处理，用替换后的URI重新匹配location；</li><li>可理解为重写（rewrite）后，发起了一个新请求，进入server模块，匹配location；</li><li>如果重新匹配循环的次数超过10次，nginx会返回500错误；</li><li>返回302 http状态码 ；</li><li>浏览器地址栏显示重地向后的url</li></ol><ul><li>break</li></ul><ol><li>结束当前的请求处理，使用当前资源，不在执行location里余下的语句；</li><li>返回302 http状态码 ；</li><li>浏览器地址栏显示重地向后的url</li></ol><ul><li>redirect</li></ul><ol><li>临时跳转，返回302 http状态码；</li><li>浏览器地址栏显示重地向后的url</li></ol><ul><li>permanent</li></ul><ol><li>永久跳转，返回301 http状态码；</li><li>浏览器地址栏显示重定向后的url</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><ul><li><p>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-service/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-service/travel/lostFound/list</a></p></li><li><p>反向代理结果：<a href="http://192.16.1.144:9999/travel-service/travel/lostFound/list">http://192.16.1.144:9999/travel-service/travel/lostFound/list</a></p><p>  location ^~ &#x2F;api&#x2F;lostFound-service {<br>  proxy_pass <a href="http://192.16.1.144:9999/travel-service">http://192.16.1.144:9999/travel-service</a>;<br>  proxy_redirect off;<br>  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>  proxy_read_timeout 180s;<br>  #proxy_set_header Host $proxy_host;<br>  }</p></li><li><p>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic1/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic1/travel/lostFound/list</a></p></li><li><p>反向代理结果：<a href="http://192.16.1.144:8767/travel/lostFound/list">http://192.16.1.144:8767/travel/lostFound/list</a></p></li></ul><pre><code>location ^~ /api/lostFound-servic1/ &#123;    proxy_pass http://192.16.1.144:8767/;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre><ul><li>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic2/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic2/travel/lostFound/list</a></li><li>反向代理结果：<a href="http://192.16.1.144:8767/api/lostFound-servic2/travel/lostFound/list">http://192.16.1.144:8767/api/lostFound-servic2/travel/lostFound/list</a> (可以发现这种方式只修改location匹配字段前面的信息)</li></ul><pre><code>location ^~ /api/lostFound-servic2/ &#123;    proxy_pass http://192.16.1.144:8767;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre><ul><li>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic3/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic3/travel/lostFound/list</a></li><li>反向代理结果：<a href="http://192.16.1.144:8767/travel/lostFound/list">http://192.16.1.144:8767/travel/lostFound/list</a></li></ul><pre><code>location ^~ /api/lostFound-servic3 &#123;    rewrite /api/lostFound-servic3/(.*) /$1 break;    proxy_pass http://192.16.1.144:8767;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre><ul><li>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic4/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic4/travel/lostFound/list</a></li><li>反向代理结果：<a href="http://192.16.1.144:9999/travel-service/travel/lostFound/list">http://192.16.1.144:9999/travel-service/travel/lostFound/list</a></li></ul><pre><code>location ^~ /api/lostFound-servic4/ &#123;    proxy_pass http://192.16.1.144:9999/travel-service/;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre><ul><li>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic5/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic5/travel/lostFound/list</a></li><li>反向代理结果：<a href="http://192.16.1.144:9999/travel-service/travel/lostFound/list">http://192.16.1.144:9999/travel-service/travel/lostFound/list</a></li><li>类比上一条可以发现：location和proxy_pass结尾都写<code>/</code>等价于都不写</li></ul><pre><code>location ^~ /api/lostFound-servic5 &#123;    proxy_pass http://192.16.1.144:9999/travel-service;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre><ul><li>访问Url：   <a href="http://192.16.1.144:5556/api/lostFound-servic6/travel/lostFound/list">http://192.16.1.144:5556/api/lostFound-servic6/travel/lostFound/list</a></li><li>反向代理结果：<a href="http://192.16.1.144:9999/travel-service/travel/lostFound/list">http://192.16.1.144:9999/travel-service/travel/lostFound/list</a></li></ul><pre><code>location ^~ /api/lostFound-servic6 &#123;    rewrite /api/lostFound-servic6/(.*) /travel-service/$1 break;    proxy_pass http://192.16.1.144:9999;    proxy_redirect off;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_read_timeout 180s;    #proxy_set_header Host $proxy_host;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx常用命令&quot;&gt;&lt;a href=&quot;#Nginx常用命令&quot; class=&quot;headerlink&quot; title=&quot;Nginx常用命令&quot;&gt;&lt;/a&gt;Nginx常用命令&lt;/h1&gt;&lt;h3 id=&quot;启动命令&quot;&gt;&lt;a href=&quot;#启动命令&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Nginx" scheme="https://ericdxf.github.io/categories/Nginx/"/>
    
    
    <category term="优化" scheme="https://ericdxf.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nginx缓存</title>
    <link href="https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E7%BC%93%E5%AD%98/"/>
    <id>https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E7%BC%93%E5%AD%98/</id>
    <published>2022-04-22T11:45:53.000Z</published>
    <updated>2022-04-22T11:39:18.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h3><h4 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h4><p><strong>语法</strong>：</p><pre><code>proxy_cache_path path [levels=levels] keys_zone=name:size [inactive=time] [max_size=size] [loader_files=number] [loader_sleep=time] [loader_threshold=time];默认值:    —上下文:    http</code></pre><p><strong>示例</strong>：</p><pre><code>proxy_cache_path /cache levels=1:2 keys_zone=cache:10m max_size=10g inactive=60m use_temp_path=off;</code></pre><ul><li><code>path</code> 指定缓存文件目录，和 proxy_temp_path 最好设置在同一文件分区下，缓存内容是先写在 temp_path，临时文件和缓存可以放在不同的文件系统，将导致文件在这两个文件系统中进行拷贝，而不是廉价的重命名操作。因此，针对任何路径，都建议将缓存和proxy_temp_path指令设置的临时文件目录放在同一文件系统。</li><li><code>level</code> 定义了缓存的层次结构，每层可以用1（最多16中选择，0-f）或2（最多256种选择，00-ff）表示，中间用 [冒号] 分隔。“levels&#x3D;1:2”表示开启1、2层级(第2层级理论有16*256个目录)。</li></ul><pre><code class="haskell">proxy_cache_path /data/nginx/cache;  # 所有缓存只有一个目录/data/nginx/cache/d7b6e5978e3f042f52e875005925e51b proxy_cache_path /data/nginx/cache levels=1:2;  # 第二层级有16*256=4096个目录/data/nginx/cache/b/51/d7b6e5978e3f042f52e875005925e51b proxy_cache_path /data/nginx/cache levels=1:1:1; #第三层级有16*16*16个目录/data/nginx/cache/b/1/5/d7b6e5978e3f042f52e87500592 proxy_cache_path /data/nginx/cache levels=2; # 第一层级有256个目录/data/nginx/cache/1b/d7b6e5978e3f042f52e875005925e51b </code></pre><ul><li><code>keys_zone</code> 指定一个共享内存空间zone，所有活动的键和缓存数据相关的信息都被存放在共享内存中，这样nginx可以快速判断一个request是否命中或者未命中缓存，1m可以存储8000个key，10m可以存储80000个key；</li><li><code>inactive</code> inactive&#x3D;30m 表示 30 分钟没有被访问的文件会被 cache manager 删除，inactive的默认值是10分钟。 需要注意的是，inactive和expired配置项的含义是不同的，expired只是缓存过期，但不会被删除，inactive是删除指定时间内未被访问的缓存文件</li><li><code>max_size</code> cache存储的最大尺寸，如果不指定，会用掉所有磁盘空间，当尺寸超过，将会基于LRU算法移除数据，以减少占用大小。nginx启动时，会创建一个“Cache manager”进程，通过“purge”方式移除数据。</li><li><code>loader_files</code> “cache loader”进程遍历文件时，每次加载的文件个数。默认为100.</li><li><code>loader_threshold</code> 每次遍历消耗时间上限。默认为200毫秒。</li><li><code>loader_sleep</code> 一次遍历之后，停顿的时间间隔，默认为50毫秒。</li></ul><h4 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h4><p><strong>语法</strong>：</p><pre><code class="css">proxy_cache zone | off;默认值:    proxy_cache off;上下文:    http, server, location</code></pre><p>指定用于页面缓存的共享内存。同一块共享内存可以在多个地方使用。off参数可以屏蔽从上层配置继承的缓存功能。zone名称由<code>proxy_cache_path</code>指令定义。</p><h4 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h4><p><strong>语法</strong>：</p><pre><code class="puppet">proxy_cache_key string;默认值:    proxy_cache_key $scheme$proxy_host$request_uri;上下文:    http, server, location</code></pre><p>定义如何生成缓存的键，比如</p><pre><code class="kotlin">proxy_cache_key &quot;$host$request_uri $cookie_user&quot;;</code></pre><p>这条指令的默认值类似于下面字符串</p><pre><code class="puppet">proxy_cache_key $scheme$proxy_host$uri$is_args$args;</code></pre><p>缓存文件并不是越多越好，所以 cache_key 的设计非常关键。代理或 URL 跳转常常会添加的无用请求参数，这就会出现不同的 cache_key 保存了多份相同的缓存内容，这对缓存效果影响很大。通过 ngx_lua 可以对 URL 参数进行过滤，保证 cache_key 唯一。</p><h4 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a>proxy_cache_valid</h4><p><strong>语法</strong>：</p><pre><code class="css">proxy_cache_valid [code ...] time;默认值:    —上下文:    http, server, location</code></pre><p>为不同的响应状态码设置不同的缓存时间。比如，下面指令</p><pre><code class="undefined">proxy_cache_valid 200 302 10m;proxy_cache_valid 404      1m;</code></pre><p>设置状态码为200和302的响应的缓存时间为10分钟，状态码为404的响应的缓存时间为1分钟。</p><p>如果仅仅指定了time，</p><pre><code class="undefined">proxy_cache_valid 5m;</code></pre><p>那么只有状态码为200、300和302的响应会被缓存。</p><p>如果使用了any参数，那么就可以缓存任何响应：</p><pre><code class="r">proxy_cache_valid 200 302 10m;proxy_cache_valid 301      1h;proxy_cache_valid any      1m;</code></pre><p>缓存参数也可以直接在响应头中设定。这种方式的优先级高于使用这条指令设置缓存时间。</p><blockquote><p>“X-Accel-Expires”响应头可以以秒为单位设置响应的缓存时间，如果值为0，表示禁止缓存响应，如果值以@开始，表示自1970年1月1日以来的秒数，响应一直会被缓存到这个绝对时间点。</p><p>如果不含“X-Accel-Expires”响应头，缓存参数仍可能被“Expires”或者“Cache-Control”响应头设置。</p><p>如果响应头含有“Set-Cookie”，响应将不能被缓存。 这些头的处理过程可以使用指令proxy_ignore_headers忽略。</p></blockquote><h4 id="proxy-ignore-headers"><a href="#proxy-ignore-headers" class="headerlink" title="proxy_ignore_headers"></a>proxy_ignore_headers</h4><p><strong>语法</strong>：</p><pre><code class="css">proxy_ignore_headers field ...;默认值:    —上下文:    http, server, location</code></pre><p>指定来自后端server的响应中的某些header不会被处理，如下几个fields可以被ignore：“X-Accel-Redirect”、“X-Accel-Expires”、“X-Accel-Limit-Rate”、“X-Accel-Buffering”、“X-Accel-Charset”、“Expires”、“Cache-Control”、“Set-Cookie”、“Vary”。“不被处理”就是nginx不会尝试解析这些header并应用它们，比如nginx处理来自后端server的“Expires”，将会影响它本地的文件cache的机制</p><p>如果不被取消，这些头部的处理可能产生下面结果：</p><blockquote><p>“X-Accel-Expires”，“Expires”，“Cache-Control”，和“Set-Cookie” 设置响应缓存的参数；</p><p>“X-Accel-Redirect”执行到指定URI的内部跳转；</p><p>“X-Accel-Limit-Rate”设置响应到客户端的传输速率限制；</p><p>“X-Accel-Buffering”启动或者关闭响应缓冲；</p><p>“X-Accel-Charset”设置响应所需的字符集。</p></blockquote><h4 id="proxy-hide-header"><a href="#proxy-hide-header" class="headerlink" title="proxy_hide_header"></a>proxy_hide_header</h4><p><strong>语法</strong>：</p><pre><code class="css">proxy_hide_header field;默认值:    —上下文:    http, server, location</code></pre><p>nginx默认不会将“Date”、“Server”、“X-Pad”，和“X-Accel-…”响应头发送给客户端。proxy_hide_header指令则可以设置额外的响应头，这些响应头也不会发送给客户端。相反的，如果希望允许传递某些响应头给客户端，可以使用proxy_pass_header指令。</p><h4 id="proxy-pass-header"><a href="#proxy-pass-header" class="headerlink" title="proxy_pass_header"></a>proxy_pass_header</h4><p><strong>语法</strong>：</p><pre><code class="css">proxy_pass_header field;默认值:    —上下文:    http, server, location</code></pre><p>允许传送被屏蔽的后端服务器响应头到客户端。</p><h4 id="proxy-cache-min-uses"><a href="#proxy-cache-min-uses" class="headerlink" title="proxy_cache_min_uses"></a>proxy_cache_min_uses</h4><pre><code class="css">proxy_cache_min_uses number;默认值:    proxy_cache_min_uses 1;上下文:    http, server, location</code></pre><p>设置响应被缓存的最小请求次数。默认为1，当客户端发送相同请求达到规定次数后，nginx才对响应数据进行缓存；指定请求至少被发送了多少次以上时才缓存，可以防止低频请求被缓存</p><h4 id="proxy-cache-use-stale"><a href="#proxy-cache-use-stale" class="headerlink" title="proxy_cache_use_stale"></a>proxy_cache_use_stale</h4><p><strong>语法</strong>：</p><pre><code class="vbnet">proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_404 | off ...;默认值:    proxy_cache_use_stale off;上下文:    http, server, location</code></pre><p>如果后端服务器出现状况，nginx是可以使用过期的响应缓存的。这条指令就是定义何种条件下允许开启此机制。这条指令的参数与proxy_next_upstream指令的参数相同。</p><p>此外，updating参数允许nginx在正在更新缓存的情况下使用过期的缓存作为响应。这样做可以使更新缓存数据时，访问源服务器的次数最少。</p><p>在植入新的缓存条目时，如果想使访问源服务器的次数最少，可以使用proxy_cache_lock指令。</p><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><p><a href="https://blog.csdn.net/weixin_30795127/article/details/97385091#proxy_cache_valid">https://blog.csdn.net/weixin_30795127/article/details/97385091#proxy_cache_valid</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Nginx缓存&quot;&gt;&lt;a href=&quot;#Nginx缓存&quot; class=&quot;headerlink&quot; title=&quot;Nginx缓存&quot;&gt;&lt;/a&gt;Nginx缓存&lt;/h3&gt;&lt;h4 id=&quot;proxy-cache-path&quot;&gt;&lt;a href=&quot;#proxy-cache-path&quot;</summary>
      
    
    
    
    <category term="Nginx" scheme="https://ericdxf.github.io/categories/Nginx/"/>
    
    
    <category term="优化" scheme="https://ericdxf.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nginx部署</title>
    <link href="https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E5%AE%89%E8%A3%85/"/>
    <id>https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E5%AE%89%E8%A3%85/</id>
    <published>2022-04-22T11:45:53.000Z</published>
    <updated>2022-04-22T11:38:48.099Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h3><h5 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h5><pre><code>//一键安装上面四个依赖yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</code></pre><h5 id="2-下载并解压安装包"><a href="#2-下载并解压安装包" class="headerlink" title="2.下载并解压安装包"></a>2.下载并解压安装包</h5><pre><code>//创建一个文件夹cd /usr/localmkdir nginxcd nginx//下载tar包wget http://nginx.org/download/nginx-1.18.0.tar.gztar -xvf nginx-1.18.0.tar.gz</code></pre><h5 id="3-安装nginx"><a href="#3-安装nginx" class="headerlink" title="3.安装nginx"></a>3.安装nginx</h5><pre><code>//进入nginx目录cd /usr/local/nginx//进入目录cd nginx-1.18.0//执行命令./configure//执行make命令make//执行make install命令make install</code></pre><h5 id="4-配置nginx-conf"><a href="#4-配置nginx-conf" class="headerlink" title="4.配置nginx.conf"></a>4.配置nginx.conf</h5><pre><code>// 打开配置文件vim /usr/local/nginx/conf/nginx.conf</code></pre><h5 id="5-启动命令"><a href="#5-启动命令" class="headerlink" title="5.启动命令"></a>5.启动命令</h5><pre><code>/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf</code></pre><h5 id="6-添加到环境变量"><a href="#6-添加到环境变量" class="headerlink" title="6.添加到环境变量"></a>6.添加到环境变量</h5><pre><code>ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</code></pre><p>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;就是环境变量目录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Nginx部署&quot;&gt;&lt;a href=&quot;#Nginx部署&quot; class=&quot;headerlink&quot; title=&quot;Nginx部署&quot;&gt;&lt;/a&gt;Nginx部署&lt;/h3&gt;&lt;h5 id=&quot;1-安装依赖包&quot;&gt;&lt;a href=&quot;#1-安装依赖包&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="Nginx" scheme="https://ericdxf.github.io/categories/Nginx/"/>
    
    
    <category term="部署" scheme="https://ericdxf.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>将Nginx注册为windows系统服务</title>
    <link href="https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E9%85%8D%E7%BD%AE%E6%88%90Windows%E6%9C%8D%E5%8A%A1/"/>
    <id>https://ericdxf.github.io/2022/04/22/Nginx/Nginx%E9%85%8D%E7%BD%AE%E6%88%90Windows%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-04-22T11:45:53.000Z</published>
    <updated>2022-04-22T11:39:57.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将Nginx注册为windows系统服务"><a href="#将Nginx注册为windows系统服务" class="headerlink" title="将Nginx注册为windows系统服务"></a>将Nginx注册为windows系统服务</h3><ul><li>在项目主页内找到winsw的下载页面（我用的是最新2.0.2版本，你可以下载最新的）</li></ul><p><a href="http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/2.0.2/">http://repo.jenkins-ci.org/releases/com/sun/winsw/winsw/2.0.2/</a></p><p>下载的文件：winsw-2.9.0-bin.exe</p><ul><li>nginx项目页面下载nginx windows版本</li></ul><p><a href="http://nginx.org/">http://nginx.org</a></p><p>把nginx压缩包解压放到指定目录，例如我放的是d盘根目录。特别强调路径不要带空格的，否则会启动失败。</p><p>nginx安装目录是：<code>E:\myProgram\nginx-1.14.0</code></p><ul><li><p>将winsw-2.9.0-bin.exe复制到nginx目录：E:\myProgram\nginx-1.14.0，并将其改成nginx-service.exe </p></li><li><p>新建一个xml文件nginx-service.xml，名称一定要与上面的.exe上的文件名一致的哦。文件内容如下：</p></li></ul><pre><code>&lt;service&gt;  &lt;id&gt;nginx&lt;/id&gt;  &lt;name&gt;nginx&lt;/name&gt;  &lt;description&gt;nginx&lt;/description&gt;  &lt;env name=&quot;path&quot; value=&quot;E:\myProgram\nginx-1.14.0&quot;/&gt;  &lt;executable&gt;E:/myProgram/nginx-1.14.0/nginx.exe&lt;/executable&gt;  &lt;arguments&gt;-p E:/myProgram/nginx-1.14.0&lt;/arguments&gt;  &lt;logpath&gt;E:/myProgram/nginx-1.14.0/logs/&lt;/logpath&gt;  &lt;logmode&gt;roll&lt;/logmode&gt;&lt;/service&gt;</code></pre><ul><li>运行Windows cmd命令，进入nginx目录：运行nginx-service.exe install将其注册为windws系统服务。当配置错误（就是系统服务中有了但是启动不了）或者是要卸载它的时候运行：nginx-service.exe uninstall</li></ul><p>​再运行Windows cmd命令，输入services.msc,就可以在系统服务中看到nginx服务，右击启动就可以了，访问<a href="http://localhost:8088出现nginx页面，安装成功。">http://localhost:8088出现nginx页面，安装成功。</a> 因为我这台电脑80端口被占用了，然后就使用了8088端口</p><p>​如果出现错误信息，可在nginx的日志文件logs查看。刚开始在测试时一直启动服务失败，原因是按照网络上的（旧版）配置文件启动不成功，希望可以少让大家走一些弯路，当时我心里的那个苦啊，没有找到正确的话，捣鼓的让你欲哭无泪。旧版的配置文件如下（注意与4中对比）：</p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;将Nginx注册为windows系统服务&quot;&gt;&lt;a href=&quot;#将Nginx注册为windows系统服务&quot; class=&quot;headerlink&quot; title=&quot;将Nginx注册为windows系统服务&quot;&gt;&lt;/a&gt;将Nginx注册为windows系统服务&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="Nginx" scheme="https://ericdxf.github.io/categories/Nginx/"/>
    
    
    <category term="优化" scheme="https://ericdxf.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>sshkey内容配置</title>
    <link href="https://ericdxf.github.io/2019/03/22/Git/sshkey%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE/"/>
    <id>https://ericdxf.github.io/2019/03/22/Git/sshkey%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE/</id>
    <published>2019-03-22T09:45:53.000Z</published>
    <updated>2022-04-22T11:00:08.614Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ssh-keygen -t rsa -C <a href="mailto:&#x64;&#117;&#x78;&#102;&#64;&#x71;&#x64;&#99;&#x61;&#x72;&#x65;&#x73;&#46;&#x63;&#x6e;">&#x64;&#117;&#x78;&#102;&#64;&#x71;&#x64;&#99;&#x61;&#x72;&#x65;&#x73;&#46;&#x63;&#x6e;</a> -b 1024<br>在git bash中使用上面的命令生成rsa公私钥，部分软件类似winscp要求使用ppk类型的私钥，需要使用puttygen工具进行转换即可</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ssh-keygen -t rsa -C &lt;a href=&quot;mailto:&amp;#x64;&amp;#117;&amp;#x78;&amp;#102;&amp;#64;&amp;#x71;&amp;#x64;&amp;#99;&amp;#x61;&amp;#x72;&amp;#x65;&amp;#x73;&amp;#46;&amp;#x63;&amp;#x6e;</summary>
      
    
    
    
    <category term="Git" scheme="https://ericdxf.github.io/categories/Git/"/>
    
    
    <category term="Git基础" scheme="https://ericdxf.github.io/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySql常见错误整理</title>
    <link href="https://ericdxf.github.io/2018/09/03/MySql/MySql%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%95%B4%E7%90%86/"/>
    <id>https://ericdxf.github.io/2018/09/03/MySql/MySql%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%95%B4%E7%90%86/</id>
    <published>2018-09-03T09:45:53.000Z</published>
    <updated>2022-04-22T11:00:49.520Z</updated>
    
    <content type="html"><![CDATA[<p>mysql数据库时间和本地时间相差13个小时，原因是mysql默认使用的是CST市区，这个是美国中部时间，和北京时间刚好相差13个小时<br>修改方法就是在<code>/etc/my.cnf</code>文件中添加一行代码即可。</p><pre><code>default-time-zone = &#39;+08:00&#39; </code></pre><p>添加完成记得重启下mysql服务</p><pre><code>[root@VM_94_149_centos home]# service mysqld restart</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mysql数据库时间和本地时间相差13个小时，原因是mysql默认使用的是CST市区，这个是美国中部时间，和北京时间刚好相差13个小时&lt;br&gt;修改方法就是在&lt;code&gt;/etc/my.cnf&lt;/code&gt;文件中添加一行代码即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;default</summary>
      
    
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>GROUP BY小记</title>
    <link href="https://ericdxf.github.io/2018/08/22/MySql/GROUPBY%E5%B0%8F%E8%AE%B0/"/>
    <id>https://ericdxf.github.io/2018/08/22/MySql/GROUPBY%E5%B0%8F%E8%AE%B0/</id>
    <published>2018-08-22T09:45:53.000Z</published>
    <updated>2022-04-22T11:01:21.061Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域”，然后针对若干个“小区域”进行数据处理。</li><li>下面的表是原始数据，接下来的例子都是基于这张表演示的。<br><img src="/assets/images/MySql/mysql_group_by_1.png" alt="原始表"></li></ul><hr><h3 id="简单Group-By"><a href="#简单Group-By" class="headerlink" title="简单Group By"></a>简单Group By</h3><pre><code class="sql">select 类别, sum(数量) as 数量之和  from A  group by 类别  </code></pre><p>返回结果如下表，实际上就是分类汇总。<br><img src="/assets/images/MySql/mysql_group_by_2.png" alt="简单GROUP BY"></p><h3 id="Group-By-和-Order-By"><a href="#Group-By-和-Order-By" class="headerlink" title="Group By 和 Order By"></a>Group By 和 Order By</h3><pre><code class="sql">select 类别, sum(数量) AS 数量之和from Agroup by 类别order by sum(数量) desc</code></pre><p>返回结果如下表<br><img src="/assets/images/MySql/mysql_group_by_3.png" alt="添加 Order By"></p><h3 id="Group-By-All"><a href="#Group-By-All" class="headerlink" title="Group By All"></a>Group By All</h3><pre><code class="sql">select 类别, 摘要, sum(数量) as 数量之和from Agroup by all 类别, 摘要</code></pre><p>这种方式可以多指定一个列，多个列都相同才会被分到同一组。<br>SQL中多指定“摘要”字段，其原因在于“多列分组”中包含了“摘要字段”，其执行结果如下表<br><img src="/assets/images/MySql/mysql_group_by_4.png" alt="Group By All"></p><h3 id="Group-By与聚合函数"><a href="#Group-By与聚合函数" class="headerlink" title="Group By与聚合函数"></a>Group By与聚合函数</h3><p><img src="/assets/images/MySql/mysql_group_by_8.jpg" alt="Group By All"></p><h3 id="Having与Where的区别"><a href="#Having与Where的区别" class="headerlink" title="Having与Where的区别"></a>Having与Where的区别</h3><ul><li>where 子句的作用是在对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数，使用where条件过滤出特定的行。</li><li>having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，条件中经常包含聚组函数，使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组。<pre><code class="sql">select 类别, sum(数量) as 数量之和 from Agroup by 类别having sum(数量) &gt; 18</code></pre>上面的SQL语句执行时会正确筛选出接过来，如果吧having替换成where则会报错<h3 id="Compute"><a href="#Compute" class="headerlink" title="Compute"></a>Compute</h3><pre><code class="sql">select *from Awhere 数量&gt;8compute max(数量),min(数量),avg(数量)</code></pre>执行效果如下<br><img src="/assets/images/MySql/mysql_group_by_6.png" alt="Compute"><h3 id="Compute-By"><a href="#Compute-By" class="headerlink" title="Compute By"></a>Compute By</h3><pre><code class="sql">select *from Awhere 数量&gt;8order by 类别compute max(数量),min(数量),avg(数量) by 类别</code></pre>执行效果如下<br><img src="/assets/images/MySql/mysql_group_by_7.png" alt="Compute"></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;“Group By”从字面意义上理解就是根据“By”指定的规则对数据进行分组，所谓的分组就是将一个“数据集”划分成若干个“小区域</summary>
      
    
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>MySql初始化及用户创建</title>
    <link href="https://ericdxf.github.io/2018/08/17/MySql/MySql%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA/"/>
    <id>https://ericdxf.github.io/2018/08/17/MySql/MySql%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%94%A8%E6%88%B7%E5%88%9B%E5%BB%BA/</id>
    <published>2018-08-17T09:45:53.000Z</published>
    <updated>2022-04-22T11:00:32.331Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS安装MySql8.0之后，部分配置和之前的5.7有比较大的差异，在这里整理一下<br>使用的安装方式是rpm安装</p><pre><code>#wget http://dev.mysql.com/get/mysql80-community-release-el7-1.noarch.rpm  rpm -ivh mysql80-community-release-el7-1.noarch.rpm  </code></pre><p>然后执行安装命令</p><pre><code>yum -y install mysql mysql-server mysql-devel  </code></pre><p>再次执行安装命令可查看安装情况，会给出提示，表示安装成功</p><pre><code>[root@VM_94_149_centos www]# yum -y install mysql mysql-server mysql-develLoaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfilePackage mysql-community-client-8.0.12-1.el7.x86_64 already installed and latest versionPackage mysql-community-server-8.0.12-1.el7.x86_64 already installed and latest versionPackage mysql-community-devel-8.0.12-1.el7.x86_64 already installed and latest versionNothing to do</code></pre><p>其他一些相关指令记录如下<br>查看默认密码</p><pre><code>mysql&gt; grep &quot;A temporary password&quot; /var/log/mysqld.log</code></pre><p>修改默认密码</p><pre><code>mysql&gt; ALTER USER USER() IDENTIFIED BY &#39;newPassword&#39;;</code></pre><p>创建用户</p><pre><code>mysql&gt; create user eric@&#39;%&#39; identified by &#39;your password&#39;;</code></pre><p>由于机密方式不同导致连接不上的问题处理</p><pre><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;your password&#39; PASSWORD EXPIRE NEVER;mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;your password&#39;;mysql&gt; flush privileges;</code></pre><p>授权，默认创建的用户权限是usage,就是无权限，只能登录而已，（all：所有权限，这里有select,update等等权限，可以去搜一下；后面的*.*：指定数据库.指定表，这里是所有；to后面就是你刚才创建的用户）</p><pre><code>mysql&gt; grant all on *.* to &#39;eric&#39;@&#39;%&#39;;</code></pre><p>需要注意的一点是，8.0以后的MySql版本里密码验证是很严格的，必须要有大小写字母和特殊字符，上面的your password替换时要注意下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CentOS安装MySql8.0之后，部分配置和之前的5.7有比较大的差异，在这里整理一下&lt;br&gt;使用的安装方式是rpm安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#wget http://dev.mysql.com/get/mysql80-community-release-el</summary>
      
    
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/categories/MySql/"/>
    
    
    <category term="MySql" scheme="https://ericdxf.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Android系统路径</title>
    <link href="https://ericdxf.github.io/2017/10/18/Android/Android%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84/"/>
    <id>https://ericdxf.github.io/2017/10/18/Android/Android%E7%B3%BB%E7%BB%9F%E8%B7%AF%E5%BE%84/</id>
    <published>2017-10-18T09:45:53.000Z</published>
    <updated>2022-04-22T10:57:37.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-通过Environment获取的"><a href="#1-通过Environment获取的" class="headerlink" title="1.通过Environment获取的"></a>1.通过Environment获取的</h3><p>Environment.getDataDirectory().getPath()<br>获得根目录&#x2F;data 内部存储路径</p><p>Environment.getDownloadCacheDirectory().getPath()<br>获得缓存目录&#x2F;cache</p><p>Environment.getExternalStorageDirectory().getPath()<br>获得SD卡目录&#x2F;mnt&#x2F;sdcard（获取的是手机外置sd卡的路径）</p><p>Environment.getRootDirectory().getPath()<br>获得系统目录&#x2F;system<br><strong>这些获取的都是应用外部路径。</strong></p><h3 id="2-通过Context获取的"><a href="#2-通过Context获取的" class="headerlink" title="2.通过Context获取的"></a>2.通过Context获取的</h3><p>Context.getFilesDir().getPath()<br>用于获取APP的files目录 &#x2F;data&#x2F;data&#x2F;&lt;application package&gt;&#x2F;files</p><p>Context.getCacheDir().getPath()<br>用于获取APP的cache目录 &#x2F;data&#x2F;data&#x2F;&lt;application package&gt;&#x2F;cache目录</p><p>Context.getExternalFilesDir().getPath()<br>用于获取APP的在SD卡中的cache目录&#x2F;mnt&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&lt;application package&gt;&#x2F;files</p><p>Context.getExternalCacheDir().getPath()<br>用于获取APP的在SD卡中的cache目录&#x2F;mnt&#x2F;sdcard&#x2F;Android&#x2F;data&#x2F;&lt;application package&gt;&#x2F;cache<br><strong>后两个获取的是应用内部路径，即随着应用卸载会一起删除掉。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-通过Environment获取的&quot;&gt;&lt;a href=&quot;#1-通过Environment获取的&quot; class=&quot;headerlink&quot; title=&quot;1.通过Environment获取的&quot;&gt;&lt;/a&gt;1.通过Environment获取的&lt;/h3&gt;&lt;p&gt;Enviro</summary>
      
    
    
    
    <category term="Android" scheme="https://ericdxf.github.io/categories/Android/"/>
    
    
    <category term="安卓基础" scheme="https://ericdxf.github.io/tags/%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="https://ericdxf.github.io/2017/09/30/Git/%E9%9A%8F%E7%AC%94/"/>
    <id>https://ericdxf.github.io/2017/09/30/Git/%E9%9A%8F%E7%AC%94/</id>
    <published>2017-09-30T09:45:53.000Z</published>
    <updated>2022-04-22T10:59:56.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The biggest thing that makes Google’s code so good is simple:code review.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;The biggest thing that makes Google’s code so good is simple:code review.&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="notes" scheme="https://ericdxf.github.io/categories/notes/"/>
    
    
    <category term="随笔" scheme="https://ericdxf.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Git分支操作</title>
    <link href="https://ericdxf.github.io/2017/08/31/Git/Git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/"/>
    <id>https://ericdxf.github.io/2017/08/31/Git/Git%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/</id>
    <published>2017-08-31T09:45:53.000Z</published>
    <updated>2022-05-16T08:27:44.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>首先，我们创建dev分支，然后切换到dev分支：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git checkout -b devSwitched to a new branch &#39;dev&#39;</code></pre><p>需要注意的是，上述这种方式创建的分支是从当前分支迁出一个新的本地分支，提交之后推送的话会提示需要设置远程分支</p><pre><code>D:\workspace\WebWorkspace\Lover (test -&gt; origin)λ git pushfatal: The current branch test has no upstream branch.To push the current branch and set the remote as upstream, use    git push --set-upstream origin test</code></pre><p>此时按照上面提示的添加–set-upstream origin <code>分支名</code>就可以了。<br>如果想从远程直接迁出分支到本地的话，可以使用如下命令<code>git checkout -b 本地分支名 远程分支名(可通过git branch-a查看)</code></p><pre><code>[root@VM_94_149_centos Lover]# git checkout -b branch_du remotes/origin/branch_duBranch branch_du set up to track remote branch branch_du from origin.Switched to a new branch &#39;branch_du&#39;</code></pre><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><p><code>git branch dev</code><br><code>git checkout dev</code></p><h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p><code>git barnch</code>命令是查看分支状态，如下面的调用，显示的是所有的分支，以及当前所在的分支是 dev</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git branch* dev  master</code></pre><p>想要查看远程分支的话，用<code>git branch -a</code></p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git branch -a* dev  master  remotes/origin/dev  remotes/origin/master</code></pre><h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>dev分支上做的改动，在切换回master之后是看不到的，因为这是在这个分支上进行的改动。那么当我们切换回master后如何把分支上的代码合并过来呢，就是通过调用<code>git merge dev</code>这个命令了。</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git merge devUpdating eb19384..079e10cFast-forward &quot;Git/Git分支.md&quot; | 18 ++++++++++++++++++ 1 file changed, 18 insertions(+)</code></pre><p>合并了之后，再调用<code>git checkout master</code>切换回master后，就能在主干上看到所有改动了。</p><h3 id="git-branch-d"><a href="#git-branch-d" class="headerlink" title="git branch -d ***"></a>git branch -d ***</h3><p>分支合并了之后就会要删除不用的分支，这就是删除分支的指令了。</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git branch -d devDeleted branch branch_test (was 079e10c).PS C:\workspace\AtomSpace\MarkDowns&gt; git branch* master</code></pre><p>但是如果分支没有合并的话，直接删除会报错：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git branch -d deverror: The branch &#39;dev&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D dev&#39;.</code></pre><p>根据提示也可以看出来，删除没有提交的分支的话需要调用<code>git branch -D dev</code>来强行删除。<br><strong>注意：上面说的所有的分支操作都是在本地仓库进行的，只有在<code>git push</code>之后远程仓库才会有相应变化</strong></p><h3 id="git-push-origin-d-lt-branch-name-gt"><a href="#git-push-origin-d-lt-branch-name-gt" class="headerlink" title="git push origin -d &lt;branch name&gt;"></a>git push origin -d &lt;branch name&gt;</h3><p>那么如何删除远程的分支呢，需要调用这个指令<code>git push origin -d &lt;branch name&gt;</code>，下面是调用示例：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git push origin -d devTo https://github.com/ericdxf/Record.git - [deleted]         dev</code></pre><h3 id="git-解决冲突"><a href="#git-解决冲突" class="headerlink" title="git 解决冲突"></a>git 解决冲突</h3><p>合并代码时难免会出现冲突，毕竟是多人协作搞出来的，难免出现大家修改一个文件的问题，这是会提示这个：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git merge feature1Auto-merging Git/readme.txtCONFLICT (content): Merge conflict in Git/readme.txtAutomatic merge failed; fix conflicts and then commit the result.</code></pre><p>此时在编辑器中能看到出现冲突的地方，在选择了留下哪部分代码解决了冲突之后，再进行<code>git add</code> <code>git commit</code>提交代码，就解决了这个冲突。</p><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git statusOn branch devChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   &quot;readme.md&quot;no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git stashSaved working directory and index state WIP on dev: 3182e2e 提交解决冲突操作</code></pre><p>此时切换到发布分支上去checkout一个bug101分支，解决了bug之后，代码合并到主干上，然后把bug分支删除。此时应该切换回我们的dev开发分支上继续我们之前的开发：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git checkout devSwitched to branch &#39;dev&#39;PS C:\workspace\AtomSpace\MarkDowns&gt; git statusOn branch devnothing to commit, working tree clean</code></pre><p>此时你会发现，之前写的没有提交的部分都不见了，因为被<code>git stash</code>命令储藏起来了，那如何把这些代码取出来呢，有两种方式：</p><ul><li><code>git stash apply</code> + <code>git stash drop</code><br>用git stash apply恢复了代码之后，stash内容并不删除，所以要再调用一次<code>git stash drop</code>命令来删除。</li></ul><p>但有一点要注意，**<code>drop</code>命令只会删除最上面一次stash，并不是清空，应该是利用弹栈的方式，需要注意。**</p><ul><li><code>git stash pop</code><br>这个命令就是上面两个命令的叠加了，取出存储的数据之后同时删除存储库中的数据。</li><li><code>git stash list</code><br>这个命令可以查看当前存储的数量，如下：<pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git stash liststash@&#123;0&#125;: WIP on master: 3182e2e 提交信息1stash@&#123;1&#125;: WIP on dev: 3182e2e 提交信息2</code></pre></li></ul><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>要查看远程库的信息时，用<code>git remote</code>，远程库的名称默认为<strong>origin</strong></p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git remoteorigin</code></pre><p><code>git remote -v</code>能查看更详细的信息，包括远程仓库的地址：</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git remote -vorigin  https://github.com/ericdxf/Record.git (fetch)origin  https://github.com/ericdxf/Record.git (push)</code></pre><p><code>git remote add origin &lt;url&gt;</code>这个是添加远程仓库的指令，那想换新的仓库怎么办呢，很简单。首先移除远程仓库：<br><code>git remote rm origin</code>之后再添加新的远程库就好了。</p><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>命令<code>git tag &lt;name&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id；<br><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...</code>可以指定标签信息；<br><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...</code>可以用PGP签名标签；<br>命令<code>git tag</code>可以查看所有标签。<br>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；<br>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；<br>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；<br>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-checkout&quot;&gt;&lt;a href=&quot;#git-checkout&quot; class=&quot;headerlink&quot; title=&quot;git checkout&quot;&gt;&lt;/a&gt;git checkout&lt;/h3&gt;&lt;p&gt;首先，我们创建dev分支，然后切换到dev分支：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Git" scheme="https://ericdxf.github.io/categories/Git/"/>
    
    
    <category term="Git基础" scheme="https://ericdxf.github.io/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git代码首次提交到远程仓库</title>
    <link href="https://ericdxf.github.io/2017/08/30/Git/Git%E4%BB%A3%E7%A0%81%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>https://ericdxf.github.io/2017/08/30/Git/Git%E4%BB%A3%E7%A0%81%E9%A6%96%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2017-08-30T09:45:53.000Z</published>
    <updated>2022-04-22T10:58:39.943Z</updated>
    
    <content type="html"><![CDATA[<p>很多人接触Git后的第一步操作就是提交本地的代码到远程仓库，包括之前是使用SVN等其他版本控制工具的用户。我们这里就来详细介绍一下如何把本地的代码关联到远成仓库。</p><p>首先，要有一个远程仓库，其实按照Git的分布式原理，任何一台电脑都可以作为一个远程仓库。但在实际的使用中，往往需要这个远程仓库保持全天24小时不停地运行，不然不能保证多人协作下的实时性。但是每个项目都单独搭建这么一台仓库也是费时费力的，好在前辈们已经早已想到了这个问题，GitHub就是这样一个大型的代码仓库，全世界无数的代码都托管在上面，类似的还有GitLab、码云等。当然托管上去后，你的代码就可以被所有人查看了。可以通过付费的方式设置为私有的，这个就要量力而行了。</p><ol><li>好了，貌似有些跑偏了，现在就先在GitHub上新建一个远程仓库：</li></ol><p><img src="/assets/images/git_new_repository.png" alt="test"><br>之后填写仓库的信息：<br><img src="/assets/images/git_new_repository_1.png" alt="test"><br>仓库创建好了之后就可以把仓库的地址拷出来备用了：<br><img src="/assets/images/git_new_repository_path.png" alt="test"></p><ol start="2"><li>然后就是打开你的项目所在目录，要把本地的代码提交到远程仓库有两种方法，第一种是先把远程仓库克隆到本地，再把代码拷进去，然后提交代码。但是这种方法不推荐，更推荐的方法是先在本地代码所在路径建立一个本地仓库,Git支持把远程仓库和一个已有的本地仓库关联。我们详细介绍一下这个方式：<br>首先进入项目的根目录，执行命令<code>git init</code>,生成本地仓库：<pre><code>PS E:\respositoryTest&gt; git initInitialized empty Git repository in E:/respositoryTest/.git/</code></pre></li><li>然后把需要提交的代码关联到本地仓库中，当然前提是要先提交正确的<code>ignore</code>文件，这个文件后期也可以修改，但是会麻烦一些，在另一篇文章中有详细的介绍。执行命令<code>git add .</code>:<pre><code>PS E:\respositoryTest&gt; git add .</code></pre></li><li>接下来就是关联本地仓库到远程仓库，执行命令<code>git remote add origin &lt;url&gt;</code>，其中的url就是上面再GitHub中获取到的远程仓库地址：<pre><code>PS E:\respositoryTest&gt; git remote add origin https://github.com/ericdxf/test1.git</code></pre></li><li>接下来要先把远程仓库中的代码同步一下，虽然是个空仓库，但也有一些<code>README.md</code> <code>ignore</code>文件等，不同步的话等下的提交会报错的：<br>&#96;&#96;&#96;<br>PS E:\respositoryTest&gt; git pull origin master –allow-unrelated-histories<br>remote: Counting objects: 3, done.<br>remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0<br>Unpacking objects: 100% (3&#x2F;3), done.<br>From <a href="https://github.com/ericdxf/test1">https://github.com/ericdxf/test1</a></li></ol><ul><li>branch            master     -&gt; FETCH_HEAD</li><li>[new branch]      master     -&gt; origin&#x2F;master<br>&#96;&#96;&#96;<br>可以看到更新下来了三个文件，其实更新代码只要<code>git pull origin master</code>就好了，但是首次更新的话需要添加<code> --allow-unrelated-histories</code>后缀，不加的话会报错<code>fatal: refusing to merge unrelated histories</code>,这个问题是在Git 2.9.0之后的版本才出现的，以前的版本不加也可以正常工作，具体原因应该是为了增强安全性而加的处理吧。</li></ul><ol start="6"><li>接下来是把代码提交到本地仓库中，调用<code>git commit -m 提交信息</code>，提交信息就是你的这次改动的内容；一定要认真填写，不然版本多了之后想再查询之前的提交信息时，就会很麻烦。<pre><code>PS E:\respositoryTest&gt; git commit -m &quot;first commit&quot;[master 7e2adca] first commit 1 file changed, 4 insertions(+) create mode 100644 try.txt</code></pre></li><li>最后一步就是把本地仓库的代码提交到远程仓库中，<code>git push origin master</code>,<code>master</code>是分支的名字，没有分支的话，默认的就是这个名为<code>master</code>的主干了。<pre><code>PS E:\respositoryTest&gt; git push origin masterCounting objects: 3, done.Delta compression using up to 8 threads.Compressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 333 bytes | 333.00 KiB/s, done.Total 3 (delta 0), reused 0 (delta 0)To https://github.com/ericdxf/test1.gitf715821..7e2adca  master -&gt; master</code></pre><img src="/images/git_new_repository_success.png" alt="end"></li></ol><p>好了，到这里，代码就关联到了GitHub中。 ^_^</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;很多人接触Git后的第一步操作就是提交本地的代码到远程仓库，包括之前是使用SVN等其他版本控制工具的用户。我们这里就来详细介绍一下如何把本地的代码关联到远成仓库。&lt;/p&gt;
&lt;p&gt;首先，要有一个远程仓库，其实按照Git的分布式原理，任何一台电脑都可以作为一个远程仓库。但在实际</summary>
      
    
    
    
    <category term="Git" scheme="https://ericdxf.github.io/categories/Git/"/>
    
    
    <category term="Git基础" scheme="https://ericdxf.github.io/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git常用操作命令记录</title>
    <link href="https://ericdxf.github.io/2017/08/30/Git/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://ericdxf.github.io/2017/08/30/Git/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/</id>
    <published>2017-08-30T09:45:53.000Z</published>
    <updated>2022-04-22T10:59:19.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>选择一个路径初始化代码版本库，目录下会多一个<code>.git</code>目录，这里面保存的是当前Git存储库保存的信息，用户要严格注意不要手动修改它。</p><h3 id="git-add-xxx-xxx"><a href="#git-add-xxx-xxx" class="headerlink" title="git add xxx.xxx"></a>git add xxx.xxx</h3><p>把xxx.xxx这个文件添加到git仓库，文件名对上就好，不需要索引相对路径。</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add ."></a>git add .</h3><p>添加当前git仓库中所有的文件。</p><h3 id="git-commit-m-“提交信息”"><a href="#git-commit-m-“提交信息”" class="headerlink" title="git commit -m “提交信息”"></a>git commit -m “提交信息”</h3><p>提交所有有改动的文件到本地git仓库，包括新增和删除的文件。<br><code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</p><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，下面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><pre><code>$ git status# On branch master# Changes not staged for commit:#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)##    modified:   readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>从这些信息里能清楚地看出哪个文件有过改动，具体的改动信息呢就要通过下面这个指令来查看了。</p><h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用<code>git diff</code>这个命令看看：</p><pre><code class="git">$ git diff readme.txtdiff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software.</code></pre><p>通过这个命令可以清晰的看到那些文件有了更改，包括新增删除或者修改等情况。<br>这里的<code>HEAD</code>指的是当前分支的上一次提交，而这句话的全部内容就是比较当前分支的状态和存储库中文件的区别。</p><pre><code>git diff HEAD -- readme.txt</code></pre><p>这句话的意思就是只单独比较这一个文件的差异。<strong>HEAD^代表上一次提交，^符号的数量表示前几次提交。</strong> 下面会有详细介绍。</p><h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout ***"></a>git checkout ***</h3><p>当你对某个文件做了修改之后，有时难免会发现有些错误不该提交，需要撤销这些更改，就需要使用到这个命令了，还是先执行git status命令：</p><pre><code>Your branch is up-to-date with &#39;origin/master&#39;. Changes not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)         modified:   &quot;readme.md&quot; no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><p>从上面的信息我们可以看出我对readme.md这个文件做了修改，也提到了<code>(use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</code>，这句话的意思就是可以通过<code>git checkout -- &lt;file&gt;</code>命令来撤销某个文件的而更改:</p><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git checkout -- Git/ignore相关.md</code></pre><p>执行了这条指令之后，就会发现这个文件已经撤销到了更改之前的状态。需要注意的是，分两种情况：</p><ul><li><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ul><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>还有一点就是如果不带 <code>--</code> 符号的话就是切换分支的指令了，需要注意一下。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>首先我们要先明确一下<code>Head</code>的概念：<br><strong>Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</strong></p><pre><code>$ git reset --hard HEAD^</code></pre><p>所以这句话的意思就是回退到上个版本了。回退和撤销有几种情况一起整理一下：</p><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file。</code></p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file</code>，就回到了场景1，第二步按场景1操作。</p></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p></li></ul><h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm ."></a>git rm <em><strong>.</strong></em></h3><p>Git中的文件删除包括两种情况，一种是本地删除文件，然后提交修改到远程仓库，包括用户在资源管理器中进行删除；另一种是直接调用<code>git rm</code>命令进行删除。</p><ul><li>第一种情况：</li></ul><ol><li>在工作空间中新建一个<code>Others</code>文件夹，在其中新建一个test.txt文件，然后执行<code>git add Others/text.txt</code>添加到缓冲区，再<code>commit</code> <code>push</code>到远成仓库。</li><li>本地删除该文件，比如在文件资源管理器中右键删除等，我这里是命令行删除的。  </li><li>可以看出Git给出了提示，我可以通过<code>git add .</code>命令把文件删除操作提交到暂存区，之后推送到远程仓库。或者通过<code>git checkout Others/test.txt</code>命令来从暂存区还原这次删除。</li><li>通过提示我们可以看出，本地删除的话只是把工作区间中的文件给删除了，暂存区和本地仓库，远程仓库中的文件都没有改变。</li></ol><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; rm Others/test.txtPS C:\workspace\AtomSpace\MarkDowns&gt; git statusOn branch masterYour branch is up-to-date with &#39;origin/master&#39;.Changes not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        deleted:    Others/test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</code></pre><ul><li>第二种情况<br>通过调用<code>git rm Others/test.txt</code>命令来删除的话会删除本地文件，同时也会删除暂存区中的对应文件。我们直接看调用的情况，删除之后再调用一次<code>git status</code>命令来查看一下状态：</li></ul><pre><code>PS C:\workspace\AtomSpace\MarkDowns&gt; git rm Others/test.txtrm &#39;Others/test.txt&#39;PS C:\workspace\AtomSpace\MarkDowns&gt; git statusOn branch masterYour branch is ahead of &#39;origin/master&#39; by 1 commit.  (use &quot;git push&quot; to publish your local commits)  Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        deleted:    Others/test.txt</code></pre><p>可以看出提示我调用<code>git commit</code>来提交到远程仓库，再就是通过版本回退来恢复这次删除。这就证实了确实工作空间中的文件已经被删除了，同时暂存区中的文件也被删除了。  </p><p><strong>总结一下：第一种方式只会删除本地文件，暂存区，本地库，远程库的更新都需要手动操作；而第二种方式则会删除本地和暂存区中的文件，而本地库和远程库的更新需要再行操作</strong></p><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>当你想从远程仓库克隆项目到本地的话，就可以通过调用<code>git clone</code>命令来实现，具体调用规则如下：</p><pre><code>git clone https://github.com/ericdxf/test.git</code></pre><p>参考资料：<br>廖雪峰大神的Git教程：<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">传送门</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-init&quot;&gt;&lt;a href=&quot;#git-init&quot; class=&quot;headerlink&quot; title=&quot;git init&quot;&gt;&lt;/a&gt;git init&lt;/h3&gt;&lt;p&gt;选择一个路径初始化代码版本库，目录下会多一个&lt;code&gt;.git&lt;/code&gt;目录，这里面保</summary>
      
    
    
    
    <category term="Git" scheme="https://ericdxf.github.io/categories/Git/"/>
    
    
    <category term="Git基础" scheme="https://ericdxf.github.io/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git忽略规则</title>
    <link href="https://ericdxf.github.io/2017/08/30/Git/Git%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99/"/>
    <id>https://ericdxf.github.io/2017/08/30/Git/Git%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99/</id>
    <published>2017-08-30T09:45:53.000Z</published>
    <updated>2022-04-22T10:58:34.435Z</updated>
    
    <content type="html"><![CDATA[<p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如果没有这个文件，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：</p><pre><code class="代码块">#此为注释 – 将被 Git 忽略*.sample 　　 # 忽略所有.sample 结尾的文件!lib.sample 　# 但 lib.sample 除外/TODO 　　    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 　　   # 忽略 build/ 目录下的所有文件doc/*.txt 　　# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</code></pre><h3 id="提交代码之后修改ignore无效解决办法"><a href="#提交代码之后修改ignore无效解决办法" class="headerlink" title="提交代码之后修改ignore无效解决办法"></a>提交代码之后修改ignore无效解决办法</h3><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。<font color="#17da4d">那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</font>  </p><p>git rm -r –cached .<br>git add .<br>git commit -m ‘update .gitignore’  </p><h3 id="检查忽略地址"><a href="#检查忽略地址" class="headerlink" title="检查忽略地址"></a>检查忽略地址</h3><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<strong>ignore</strong>忽略了：</p><pre><code>$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them.</code></pre><p>你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><pre><code>$ git check-ignore -v App.class.gitignore:3:*.class    App.class</code></pre><p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><h3 id="最后附上官方的-ignore文件链接-传送门"><a href="#最后附上官方的-ignore文件链接-传送门" class="headerlink" title="最后附上官方的.ignore文件链接 传送门"></a>最后附上官方的<code>.ignore</code>文件链接 <a href="https://github.com/github/gitignore">传送门</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如果没有这个文件，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;代码块&quot;&gt;#此为注释 – 将</summary>
      
    
    
    
    <category term="Git" scheme="https://ericdxf.github.io/categories/Git/"/>
    
    
    <category term="Git基础" scheme="https://ericdxf.github.io/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
feed>
